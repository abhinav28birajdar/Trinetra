diff --git a/node_modules/ws/lib/permessage-deflate.js b/node_modules/ws/lib/permessage-deflate.js
index 41ff70e..d2712c6 100644
--- a/node_modules/ws/lib/permessage-deflate.js
+++ b/node_modules/ws/lib/permessage-deflate.js
@@ -1,6 +1,64 @@
 'use strict';
 
-const zlib = require('zlib');
+// Dummy zlib implementation for React Native compatibility
+const zlib = {
+  constants: {
+    Z_NO_FLUSH: 0,
+    Z_PARTIAL_FLUSH: 1,
+    Z_SYNC_FLUSH: 2,
+    Z_FULL_FLUSH: 3,
+    Z_FINISH: 4,
+    Z_BLOCK: 5,
+    Z_TREES: 6,
+    Z_OK: 0,
+    Z_STREAM_END: 1,
+    Z_NEED_DICT: 2,
+    Z_ERRNO: -1,
+    Z_STREAM_ERROR: -2,
+    Z_DATA_ERROR: -3,
+    Z_MEM_ERROR: -4,
+    Z_BUF_ERROR: -5,
+    Z_VERSION_ERROR: -6,
+    Z_NO_COMPRESSION: 0,
+    Z_BEST_SPEED: 1,
+    Z_BEST_COMPRESSION: 9,
+    Z_DEFAULT_COMPRESSION: -1,
+    Z_FILTERED: 1,
+    Z_HUFFMAN_ONLY: 2,
+    Z_RLE: 3,
+    Z_FIXED: 4,
+    Z_DEFAULT_STRATEGY: 0,
+    Z_DEFAULT_WINDOWBITS: 15,
+    Z_MIN_WINDOWBITS: 8,
+    Z_MAX_WINDOWBITS: 15,
+    Z_MIN_LEVEL: -1,
+    Z_MAX_LEVEL: 9,
+    Z_MIN_MEMLEVEL: 1,
+    Z_MAX_MEMLEVEL: 9,
+    Z_DEFAULT_MEMLEVEL: 8,
+    Z_MIN_CHUNK: 64,
+    Z_MAX_CHUNK: Infinity,
+    Z_DEFAULT_CHUNK: 16384
+  },
+  createDeflateRaw: () => ({
+    write: () => {},
+    flush: () => {},
+    close: () => {},
+    on: () => {},
+    once: () => {},
+    removeListener: () => {},
+    emit: () => {}
+  }),
+  createInflateRaw: () => ({
+    write: () => {},
+    flush: () => {},
+    close: () => {},
+    on: () => {},
+    once: () => {},
+    removeListener: () => {},
+    emit: () => {}
+  })
+};
 
 const bufferUtil = require('./buffer-util');
 const Limiter = require('./limiter');
diff --git a/node_modules/ws/lib/receiver.js b/node_modules/ws/lib/receiver.js
index 54d9b4f..0a82061 100644
--- a/node_modules/ws/lib/receiver.js
+++ b/node_modules/ws/lib/receiver.js
@@ -1,6 +1,6 @@
 'use strict';
 
-const { Writable } = require('stream');
+const { Writable } = require('stream-browserify');
 
 const PerMessageDeflate = require('./permessage-deflate');
 const {
diff --git a/node_modules/ws/lib/sender.js b/node_modules/ws/lib/sender.js
index a8b1da3..db700fb 100644
--- a/node_modules/ws/lib/sender.js
+++ b/node_modules/ws/lib/sender.js
@@ -2,8 +2,8 @@
 
 'use strict';
 
-const { Duplex } = require('stream');
-const { randomFillSync } = require('crypto');
+const { Duplex } = require('stream-browserify');
+const { randomFillSync } = require('crypto-browserify');
 
 const PerMessageDeflate = require('./permessage-deflate');
 const { EMPTY_BUFFER, kWebSocket, NOOP } = require('./constants');
diff --git a/node_modules/ws/lib/stream.js b/node_modules/ws/lib/stream.js
index 4c58c91..0076656 100644
--- a/node_modules/ws/lib/stream.js
+++ b/node_modules/ws/lib/stream.js
@@ -2,7 +2,7 @@
 'use strict';
 
 const WebSocket = require('./websocket');
-const { Duplex } = require('stream');
+const { Duplex } = require('stream-browserify');
 
 /**
  * Emits the `'close'` event on a stream.
diff --git a/node_modules/ws/lib/stream.js.bak b/node_modules/ws/lib/stream.js.bak
new file mode 100644
index 0000000..4c58c91
--- /dev/null
+++ b/node_modules/ws/lib/stream.js.bak
@@ -0,0 +1,161 @@
+/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */
+'use strict';
+
+const WebSocket = require('./websocket');
+const { Duplex } = require('stream');
+
+/**
+ * Emits the `'close'` event on a stream.
+ *
+ * @param {Duplex} stream The stream.
+ * @private
+ */
+function emitClose(stream) {
+  stream.emit('close');
+}
+
+/**
+ * The listener of the `'end'` event.
+ *
+ * @private
+ */
+function duplexOnEnd() {
+  if (!this.destroyed && this._writableState.finished) {
+    this.destroy();
+  }
+}
+
+/**
+ * The listener of the `'error'` event.
+ *
+ * @param {Error} err The error
+ * @private
+ */
+function duplexOnError(err) {
+  this.removeListener('error', duplexOnError);
+  this.destroy();
+  if (this.listenerCount('error') === 0) {
+    // Do not suppress the throwing behavior.
+    this.emit('error', err);
+  }
+}
+
+/**
+ * Wraps a `WebSocket` in a duplex stream.
+ *
+ * @param {WebSocket} ws The `WebSocket` to wrap
+ * @param {Object} [options] The options for the `Duplex` constructor
+ * @return {Duplex} The duplex stream
+ * @public
+ */
+function createWebSocketStream(ws, options) {
+  let terminateOnDestroy = true;
+
+  const duplex = new Duplex({
+    ...options,
+    autoDestroy: false,
+    emitClose: false,
+    objectMode: false,
+    writableObjectMode: false
+  });
+
+  ws.on('message', function message(msg, isBinary) {
+    const data =
+      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
+
+    if (!duplex.push(data)) ws.pause();
+  });
+
+  ws.once('error', function error(err) {
+    if (duplex.destroyed) return;
+
+    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
+    //
+    // - If the `'error'` event is emitted before the `'open'` event, then
+    //   `ws.terminate()` is a noop as no socket is assigned.
+    // - Otherwise, the error is re-emitted by the listener of the `'error'`
+    //   event of the `Receiver` object. The listener already closes the
+    //   connection by calling `ws.close()`. This allows a close frame to be
+    //   sent to the other peer. If `ws.terminate()` is called right after this,
+    //   then the close frame might not be sent.
+    terminateOnDestroy = false;
+    duplex.destroy(err);
+  });
+
+  ws.once('close', function close() {
+    if (duplex.destroyed) return;
+
+    duplex.push(null);
+  });
+
+  duplex._destroy = function (err, callback) {
+    if (ws.readyState === ws.CLOSED) {
+      callback(err);
+      process.nextTick(emitClose, duplex);
+      return;
+    }
+
+    let called = false;
+
+    ws.once('error', function error(err) {
+      called = true;
+      callback(err);
+    });
+
+    ws.once('close', function close() {
+      if (!called) callback(err);
+      process.nextTick(emitClose, duplex);
+    });
+
+    if (terminateOnDestroy) ws.terminate();
+  };
+
+  duplex._final = function (callback) {
+    if (ws.readyState === ws.CONNECTING) {
+      ws.once('open', function open() {
+        duplex._final(callback);
+      });
+      return;
+    }
+
+    // If the value of the `_socket` property is `null` it means that `ws` is a
+    // client websocket and the handshake failed. In fact, when this happens, a
+    // socket is never assigned to the websocket. Wait for the `'error'` event
+    // that will be emitted by the websocket.
+    if (ws._socket === null) return;
+
+    if (ws._socket._writableState.finished) {
+      callback();
+      if (duplex._readableState.endEmitted) duplex.destroy();
+    } else {
+      ws._socket.once('finish', function finish() {
+        // `duplex` is not destroyed here because the `'end'` event will be
+        // emitted on `duplex` after this `'finish'` event. The EOF signaling
+        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
+        callback();
+      });
+      ws.close();
+    }
+  };
+
+  duplex._read = function () {
+    if (ws.isPaused) ws.resume();
+  };
+
+  duplex._write = function (chunk, encoding, callback) {
+    if (ws.readyState === ws.CONNECTING) {
+      ws.once('open', function open() {
+        duplex._write(chunk, encoding, callback);
+      });
+      return;
+    }
+
+    ws.send(chunk, callback);
+  };
+
+  duplex.on('end', duplexOnEnd);
+  duplex.on('error', duplexOnError);
+  return duplex;
+}
+
+module.exports = createWebSocketStream;
diff --git a/node_modules/ws/lib/websocket-server.js b/node_modules/ws/lib/websocket-server.js
index 67b52ff..7df2e7d 100644
--- a/node_modules/ws/lib/websocket-server.js
+++ b/node_modules/ws/lib/websocket-server.js
@@ -3,9 +3,9 @@
 'use strict';
 
 const EventEmitter = require('events');
-const http = require('http');
-const { Duplex } = require('stream');
-const { createHash } = require('crypto');
+const http = require('stream-http');
+const { Duplex } = require('stream-browserify');
+const { createHash } = require('crypto-browserify');
 
 const extension = require('./extension');
 const PerMessageDeflate = require('./permessage-deflate');
diff --git a/node_modules/ws/lib/websocket.js b/node_modules/ws/lib/websocket.js
index ad8764a..090023f 100644
--- a/node_modules/ws/lib/websocket.js
+++ b/node_modules/ws/lib/websocket.js
@@ -3,13 +3,14 @@
 'use strict';
 
 const EventEmitter = require('events');
-const https = require('https');
-const http = require('http');
-const net = require('net');
-const tls = require('tls');
-const { randomBytes, createHash } = require('crypto');
-const { Duplex, Readable } = require('stream');
-const { URL } = require('url');
+const https = require('https-browserify');
+const http = require('stream-http');
+const net = {}; // Dummy object for React Native compatibility
+const tls = {}; // Dummy object for React Native compatibility
+const { randomBytes, createHash } = require('crypto-browserify');
+const { Duplex, Readable } = require('stream-browserify');
+// Use React Native's built-in URL polyfill
+const { URL } = require('react-native-url-polyfill');
 
 const PerMessageDeflate = require('./permessage-deflate');
 const Receiver = require('./receiver');
